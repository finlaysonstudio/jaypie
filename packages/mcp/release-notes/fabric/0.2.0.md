---
version: 0.2.0
date: 2026-01-22
summary: Serializer hook and breaking change to ServiceSuite.register()
---

# @jaypie/fabric v0.2.0

## New Features

### Serializer Hook

Added an optional `serializer` lifecycle hook to `fabricService` that runs after the service function and can transform the output.

**Lifecycle**:
```
Input → Parse → Field Processing (validation) → Service → Serializer → Output
```

**Example**:
```typescript
const handler = fabricService({
  input: {
    userId: { type: String },
  },
  service: ({ userId }) => ({
    id: userId,
    name: `User ${userId}`,
  }),
  serializer: ({ input, output }, context) => ({
    data: output,
    meta: { timestamp: Date.now() },
  }),
});
```

**Signature**: `({ input, output }, context?) => output | void`

**Serializer Behavior**:
- First parameter is an object with `input` and `output`
- Second parameter is the optional service context
- Returning `undefined`/`void`/`null` uses the original output
- Any other return value replaces the original
- Supports async functions
- Errors propagate normally (no special catching)

## Breaking Changes

- **`suite.register(service, category)` changed to `suite.register(service, { category })`**

This aligns with Jaypie style guidelines for function signatures. When there is a single required value, subsequent parameters should be passed as an object.

### Migration

```typescript
// Before (0.1.x)
suite.register(myService, "category");

// After (0.2.0)
suite.register(myService, { category: "category" });
```

## Why

Jaypie style specifies:
- Function definitions use object parameters: `function myFunction({ param1, param2 })`
- If there is a single required value: `function myFunction(requiredParam, { param2, param3 })` is allowed
- Ordered parameters beyond a single required value should never be used

## Types

Added new exported type:
- `SerializerFunction<TInput, TOutput, TSerializedOutput>`

## Note

For setup/teardown lifecycles (`validate`, `setup`, `teardown`), use transport adapters like `fabricLambda` which wrap services with `lambdaHandler`.
